VUE 3 //////
// Создание
Можно создать разными способами, настройка самому или через vue/cli команда:
vue-create /имяпроекта/ или через VITE

///
<img src="./assets/logo.png"> поддерживается в компонентах такая запись, src будет указывать на файл
 который находится по пути в src

Во vue @ = алиас который указывает на src;
@/components
////

v-model=/имя поля с которым надо связать/ two-way binding
v-model.lazy = позволяет обновлнять данные которые в поле с которым он связан, только после потери фокуса над элементом
с которым он связан


v-bind:/имя атрибута/="/поле с которым надо связать/" для привязки какиех то данных с компонентом
имя атрибута пример: href, id,value === v-bind:id=""
Короткая запись :bind ===v-bind

v-bind:class or :class можно создавать динамические классы пример:
:class="{'/имя класса/':todo.isCompleted}" если isCompleted = тру то данный класс примениться

v-html=/имя поля в данных/ чтобы вставить html разметку из данных

v-for="/имя для элемента in имя откуда брать этот элемент/" так же для каждого элемента должен быть задан key
пример: <li :key="/todo.id/" v-for="todo in todos">
              {{ todo.title }}
            </li>

v-once при добавлении данного атрибута для компонента все данные внутри не будут меняться, и будут отрисованы один раз, даже если соседние данные этого же компонента будут изменены, имхо как shouldComponentUpdate в реакте который возвращает true или фалсе
///

v-on:"/имя события/"="имя функции или тело функции" привязывает обработку события click,submit,mousemove
Пример: v-on:click="todos.push(какое то значение)" или v-on:click="addTodo"
v-on: === @ , можно писать @click, @dbclick

@submit.prevent preventDefault
stop stopPropaganation
capture добавляет слушатель события
self вызывает событие если именно он вызвался .currentTarget
once отработать событие только один раз
passive добавляет еще дополнительное событие поведение с поведением которое задано по умолчания
поддерживается запись @click.prevent.self
можно не передавать обработчик просто написат @submit.prevent

Клавишные события
@keyup.13 13===Enter будет срабатывать когда enter нажат
@keyup.enter
.enter === .13 === Нажать Enter
.delete = backspace || delete
.escape = Клавиши
.esc
.up
.down итд
config{
keyCodes:{
   "клавиша": код клавиши
   }
}
.клавиша ==== кастомное создание обработчика клавиши

v-if v-else v-else-if === if else при этих методах элементы будут удаляться из DOM дерева

v-show элемент будет в DOM но только style будет display none || block

computed методы должны возвращать результат вычисления и не должы быть undefined, и отрабатывают только тогда когда именно значение с которым оно работает изменилось на какое то другое, useMemo , или useCallback примерно)) у которых взависимости какое то значение,
computed методы один из способов применения, когда мы вызываем это свойство внутри компонента, и при отрисовке компонента нам
не нужно чтобы эта функция обратно вызвалась === мемоизация
computed свойства в instanse можно не вызывать, они сами подставятся

ref = ref ссылка на элемент синтаксис ref="/имя ссылки/" так сразу создастся ссылка с этим именем

/// Filters
способ применения (дааные) | имя фильтра
 | json формирует json строку
чтобы создать пишем
filters{
"имя фильтра": функция которая принимает(значение которое фильтрует) и возвращает филтьтрованное значение
}

чтоб создать компонент можно воспользоваться записью
<Имя компонента/> или воспользоваться тегом component is="//имя компонента//"
пример использования
:is="isAuth ? Reg : Auth"  Reg и Auth компоненты, только будут отображаться в зависимости от isAuth

теги vue
component тег создания vue компонента

keep-alive если поместить внутри этого тега другие компоненты, данные внутри keep-alive будут сохраняться, даже если мы уничтожим компонент внутри keep-alive, и заного в него зайдем, к примеру инпут.

slot чтобы вывести данные переданные из родительского компонента, в дочерний компонент между тегами
<Дочерний компонент> <h1 slot="имя slota">это есть слот</h1> </Дочерний компонент>

передача пропсов
v-bind:имяпропса="данные пропса"
или сразу как в реакте
имя пропса=данные пропса

чтобы принять данные в дочернем компоненте
пишем props: [перечисляем именна пропсов которые придут]


$emit('имя события которые мы хотим чтобы знали другие элементы оборачивающие компонент', данные евента)
чтобы следить за этим событием то пишем @(имя события)="событие которое должно вызываться при событии которые в $emit"

//// Роутинг
пример роутинга можно посмотреть в приложении
чтобы принять params можно писать $route.params.(имя вашего параметра) например
$route.params.id


const state={}
если превратить его в реактивный
то toRaw все изменения сбросит и он станет обратно state={}
markRaw делает чтобы reactivoe не изменился

toRefs позволяет связать данные с обьектом или определенными ключами обьекта


реактивно означает что везде меняется